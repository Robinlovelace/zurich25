---
title: "Modelling active travel with efficient, future-proof tools"
author: "Robin Lovelace"
date: "2025-10-18"
format: gfm
execute: 
  cache: true
  echo: false
  message: false
  warning: false
---



A transport models from first principles can be expressed in 4 stages, according the classic four-step model:

1. Trip generation: estimating the number of trips originating in and destined for each zone in the study area.
2. Trip distribution: determining where trips will go, often using a gravity model or similar approach.
3. Mode choice: deciding which mode of transport (e.g., car, bike, public transit) will be used for each trip.
4. Route assignment: assigning trips to specific routes on

We can question the suitability of this approach, in which each stage is treated separately and sequentially. 
It is clear that the number of trips departing from a zone is not independent of where those trips are going, the mode chosen, or the route taken: in terms of the dependencies between these stages, one could argue that the order of the stages should be reversed.
To use the approach of setting out the dependencies of a directed acyclic graph (DAG), the 4 stage model assumes the following structure:


```{mermaid}
%%| label: fig-4stage
%%| fig-cap: The 4-stage transport modelling framework presented as a linear Directed Acyclic Graph (DAG)
graph TD
    A[Trip Generation] --> B[Trip Distribution]
    B --> C[Mode Choice]
    C --> D[Route Assignment]
```

In fact, the following dependency structure may be more realistic, with trip generation, distribution and mode choice all affected by the network, the key input into route assignment.

```{mermaid}
%%| label: fig-6stage
%%| fig-cap: A 6-stage transport modelling framework with recursive dependencies between Trip Distribution and Route Assignment stages.
graph TD
    E[Network] --> D[Route Assignment: s4]
    F[Other Factors] --> C
    F --> B
    C --> D
    D --> B
    E --> B[Trip Distribution: s2]
    E --> C[Mode Choice: s3]
    B --> C
    B --> A[Trip Generation: s1]
```

This partial reversal of the order of transport modelling elements highlights the fact that the 'demand' for and actual usage of transport systems measured as the number of departures and arrivals at any given geographic entity (Trip Generation) is not a rigid input.
The number of trips taking place is *a consequence of* the transport systems and other factors that (dis)incentivise trips between origins and destinations from taking place (Trip Distribution).

These observations raise the question: why did the 4-stage model come to dominate thinking in transport modelling?
It is of course impossible to know: the decisions that led to its primacy were made many decades ago, and intentions cannot always be inferred.
However, there are various considerations that make it understandable why the 4-stage model presented in @fig-4stage has become the starting point for transport modelling instead of other more complicated approaches such as the 6-stage model presented in @fig-6stage.
My perhaps-untestable hypothesis is that the following reasons explain it, in descending order of how easy they are to justify:

1. Simplicity: 
2. Lack of data: 
3. Lack of methods:
4. Epistemic bias: Belief in the inevitability of 'demand' leading to trips being generated due to the primacy of traditional microeconomics underlying much transport planning and related fields public decision-making.

It would be easy to criticize early transport modellers as naive.
However, anyone considering ad-hominem attacks now should remember that they have the benefits of hindsight, plentiful datasets, an abundance of available methods, and near-infinite computational resources compared with early transport planning researchers and practitioners.
Of course it is now possible to consider more complex and realistic models, but that is not the point.
The question now should be how can we reform, rebuild or *retrofit* transport modelling for the needs of the 21st Century without losing much of what is good in the established practice of transport modelling.
In other words, we should not through the metaphorical baby out with the bathwater.

The first of the reasons hypothesised above (simplicity) alone can, I content, fully justify early practitioners' development of the 4-stage, without worrying about the other 3 reasons.
This is because, as applied mathematics text books tell us, good models start simple and then incrementally add complexity as they go.
The biggest issue with 4-stage model is not that it exists, but that it became entrenched.

Returning to our topic of modelling active travel with efficient, future-proof tools, these observations in fact *justify* the focus on the 4-stage model as a starting point that can be then critiqued, iterated-on, and then replaced with something more appropriate to contemporary contexts (with health a more prominent priority than coping with growth in car use, for example).

So let's go ahead and build a transport model from first principles, simplifying the 4-stage model further by collapsing Trip Generation and Distribution into a single stage that can be described as Trip Estimation (at the origin-destination level).


```{r}
#| include: false
library(tidyverse)
library(sf)
# The following parameter sets the diameter of the study area
# diameter of 1, 3, 6, 10 and 15 km associated with n_circles of 1, 2, 3, 4 and 5
n_circles = 3 # sets diameter to 6 km
if (!file.exists("zones.geojson")) {
  zones = zonebuilder::zb_zone("leeds", n_circles = n_circles)
  sf::write_sf(zones, "zones.geojson", delete_dsn = TRUE)
}
zones = sf::read_sf("zones.geojson")
study_area = zones |>
  sf::st_union()
# Uncomment the next line to check which area will be downloaded:
# osmextract::oe_find(study_area)
# The following commands can download more data than intended:
# network = osmextract::oe_get(study_area, boundary = study_area, boundary_type = "clipsrc")
network = osmextract::oe_get_network(study_area, boundary = study_area, boundary_type = "clipsrc", mode = "driving") |>
  sf::st_cast("LINESTRING")
# Remove small disconnected components
network_components = stplanr::rnet_group(network)
largest_component_id = table(network_components) |>
  sort(decreasing = TRUE) |>
  names() |>
  first()
nrow(network)
network = network |>
  slice(which(network_components == largest_component_id))
nrow(network)
```

```{r}
#| fig-cap: Road network data in the case study area (diameter 6 km around Leeds city centre)
#| label: fig-road-network
network |>
  sf::st_geometry() |>
  plot()
```

The number of trips can be estimated using spatial interaction models using data on the number of people living in each area (and their propensity to travel which depends on socio-economic and other variables) and the 'attractiveness' of each potential destination.
For the sake of simplicity and international generalisability, we will initially estimate the population as the number of residential buildings in each area multiplied by 10 and the attractiveness of each destination as the total number of OSM nodes in each.
We can of course use more refined measures such as population estimates from WorldPop but this approach, which only requires a single input data source (OSM) for route network and area-level variales, is used for illustrative purposes and to increase reproducibility in new contexts.

```{r}
#| eval: false
# Note: this chunk is kept to demonstrate that most houses are not points
osm_points = osmextract::oe_get(study_area, layer = "points", boundary = study_area, boundary_type = "clipsrc", extra_tags = "building")
osm_points |>
  sf::st_drop_geometry() |>
  count(building) |>
  arrange(desc(n))
# names(osm_points)
osm_points_resi = osm_points |>
  filter(str_detect(other_tags, "residential|house"))
osm_points_resi |>
  sf::st_geometry() |>
  plot()
```

```{r}
#| include: false
osm_polygons = osmextract::oe_get(study_area, layer = "multipolygons", boundary = study_area, boundary_type = "clipsrc", extra_tags = "building")
osm_polygons |>
  sf::st_drop_geometry() |>
  count(building) |>
  arrange(desc(n))
# names(osm_polygons)
osm_polygons_resi = osm_polygons |>
  filter(str_detect(building, "resi|house|terrace|appart|dorm")) |>
  sf::st_centroid()
# nrow(osm_polygons_resi)
# mapview::mapview(osm_polygons_resi |> sample_n(1000))
# osm_polygons_resi |>
#   sf::st_geometry() |>
#   plot() 
osm_polygons_zones = sf::st_join(
  osm_polygons_resi |> select(building),
  zones |> select(label)
) |>
  sf::st_drop_geometry() |>
  count(label, name = "population")
```

```{r}
osm_polygons_employment = osm_polygons |>
  filter(str_detect(building, "retail|comm|school|uni|off|hosp|serv|parking|super")) |>
  sf::st_centroid()
osm_emp_zones = sf::st_join(
  osm_polygons_employment |> select(building),
  zones |> select(label)
) |>
  sf::st_drop_geometry() |>
  count(label, name = "jobs")
```

```{r}
#| label: fig-sim-inputs
#| fig-cap: "Inputs to a spatial interaction model"
zones = left_join(zones, osm_polygons_zones)
zones = left_join(zones, osm_emp_zones)
zones |> 
  select(population, jobs) |>
  plot()
```

```{r}
installed_packages = installed.packages()
sf_routing_installed = "sfrouting" %in% installed_packages
if (!sf_routing_installed) {
  pak::pak("robinlovelace/sfrouting")
  pak::pak("robinlovelace/simodels")
  pak::pak("ITSleeds/pct")
}
```

Let's use the datasets presented in @fig-sim-inputs to run a spatial interaction model (SIM).

```{r}
library(simodels)
od_sim_all = si_to_od(origins = zones, destinations = zones)
# We'll remove intrazonal flows for now:
od_sim = od_sim_all |>
  filter(O != D)
names(od_sim)
```

Note that the output has duplicate columns: `si_to_od()` joins data from the origin and destination objects into the resulting OD object.

A simplistic SIM - in this case an inverse power distance decay function (negative exponential is another commonly used decay function) - can be created just based on the distance between points:

```{r unconstrained1}
# si_power = function(d, beta) (d / 1000)^beta
si_exponential = function(d, beta) exp(beta * (d / 1000))
# With flow proportional to origin population multiplied by destination jobs)
si_exp_constrained = function(d, beta, pop, jobs) {
  pop * jobs * exp(beta * (d / 1000))
}
od_calculated = si_calculate(
  od_sim,
  fun = si_exp_constrained,
  d = distance_euclidean,
  pop = origin_population,
  jobs = destination_jobs,
  beta = -0.5
  ,
  constraint_production = origin_population
  )
od_calculated |>
  select(interaction) |>
  plot(logz = TRUE)
# Plot top 100 interactions
od_calculated |>
  arrange(desc(interaction)) |>
  slice(1:50) |>
  select(interaction) |>
  plot(logz = TRUE)
# ggplot(zones) +
#   geom_point(aes(population, jobs))
ggplot(od_calculated) +
  geom_point(aes(distance_euclidean, interaction))
# sum(od_calculated$interaction) == sum(zones$population, na.rm = TRUE)
```

```{r}
# Get routes for a sample of the OD data:
od_sample = od_calculated |> 
  slice_max(interaction, n = 100)
if (!file.exists("routes.gpkg")) {
  routes = stplanr::route(
    l = od_sample,
    route_fun = cyclestreets::journey,
    plan = "quietest"
  )
  sf::write_sf(routes, "routes_quiet.gpkg", delete_dsn = TRUE)
  system("gh release upload v1 routes_quiet.gpkg --clobber")
} else {
  routes = sf::read_sf("routes_quiet.gpkg")
}
```

```{r}
routes_with_stats = routes |> 
  group_by(O, D) |> 
  mutate(
    length_route = sum(distances),
    route_hilliness = mean(gradient_segment)
    ) |> 
  ungroup()
```

```{r}
routes_go_dutch = routes_with_stats |> 
  mutate(
    pcycle_go_dutch = pct::uptake_pct_godutch_2020(
      distance = length_route,
      gradient = route_hilliness
    ),
    pcycle_govtarget = pct::uptake_pct_govtarget_2020(
      distance = length_route,
      gradient = route_hilliness
    )
  ) |> 
  mutate(
    bicycle_go_dutch = interaction * pcycle_go_dutch,
    bicycle_govtarget = interaction * pcycle_govtarget
  )
# names(routes_go_dutch)

```

```{r}
#| label: fig-rnet-go-dutch
#| fig-cap: "Route network summarising Go Dutch scenario"
rnet_go_dutch = stplanr::overline(
  routes_go_dutch,
  attrib = c("interaction", "bicycle_govtarget", "bicycle_go_dutch", "quietness", "gradient_smooth"),
  fun = list(sum = sum, mean = mean)
) |>
  transmute(
    govtarget = bicycle_govtarget_sum,
    go_dutch = bicycle_go_dutch_sum,
    total = interaction_sum,
    quietness = quietness_mean,
    gradient = gradient_smooth_mean
  )
# plot(rnet_go_dutch)
library(tmap)
tm_shape(rnet_go_dutch) +
  tm_lines(lwd = c("govtarget", "go_dutch"), lwd.free = FALSE, scale = 9, col = "quietness", palette = "-Reds")
```

```{r}
#| eval: false
#| fig-cap: "Go Dutch scenario"
rnet_go_dutch |> 
  ggplot() +
  geom_sf(aes(lwd = bicycle_go_dutch_sum)) +
  scale_linewidth_continuous(range = c(0.1, 3)) +
  labs(title = "Go Dutch scenario")
```

We can use 'All or Nothing' assignment to route the trips estimated by the SIM through the network.

```{r}
#| label: fig-dodgr-aon
#| fig-cap: "Estimated flows from All-or-Nothing assignment with dodgr"
#| eval: false
# Note: currently fails: https://github.com/UrbanAnalyst/dodgr/issues/325
# The dodgr equivalent of the above is as follows:
if (!"dodgr" %in% installed.packages()) {
  install.packages("dodgr")
}
library(dodgr)
# 1. Create dodgr graph
# Note: weight_streetnet can be time consuming
dodgr_sc = dodgr_streetnet_sc(st_bbox(study_area))
net_dodgr_full = weight_streetnet(dodgr_sc, wt_profile = "motorcar")
net_dodgr_comp = dodgr_components(net_dodgr_full)
# Clean graph to only include largest connected component
net_dodgr = net_dodgr_comp[net_dodgr_comp$component == 1, ]
head(net_dodgr)

net_dodgr_sf = dodgr_to_sf(net_dodgr)
vert_dodgr = dodgr_vertices(net_dodgr)
vert_dodgr_sf = vert_dodgr |>
  st_as_sf(coords = c("x", "y"), crs = st_crs(4326))

# 2. Map OD data to network nodes
zone_centroids_dodgr = st_centroid(zones)
# plot(zone_centroids_dodgr$geometry)
# Find nearest vertices
v_ids = dodgr::match_pts_to_verts(vert_dodgr, zone_centroids_dodgr)
vert_dodgr_centroids = vert_dodgr |> 
  slice(v_ids)
vert_dodgr_centroids |> 
  sf::st_as_sf(coords = c("x", "y")) |>
  plot()
vert_dodgr_centroids$label = zone_centroids_dodgr$label
# join with od_calculated
od_calculated_nodes = od_calculated |>
  left_join(vert_dodgr_centroids |> select(label, id), join_by(O == label)) |>
  rename(from_id = id) |>
  left_join(vert_dodgr_centroids |> select(label, id), join_by(D == label)) |>
  rename(to_id = id)

# Single route between first two zones for testing:
p = dodgr_paths(
  graph = net_dodgr,
  from = od_calculated_nodes$from_id[1],
  to = od_calculated_nodes$to_id[1]
)

flows = dodgr::dodgr_flows_aggregate(
  net_dodgr,
  from = od_calculated_nodes$from_id,
  to = od_calculated_nodes$to_id,
  flows = od_calculated$interaction,
  pairwise = TRUE,
  norm_sums = FALSE
)
# To sf
flows_sf = dodgr_to_sf(flows)
flows_sf |> 
  filter(flow > 0) |>
  ggplot() +
  geom_sf(aes(color = flow, lwd = flow))
summary(flows$flow)
summary(od_calculated$interaction)
```


```{r}
#| label: fig-aon
#| fig-cap: "Estimated flows from All-or-Nothing assignment"
#| eval: false
# Note: currently fails to generate plausible results. TODO: debug
# Create cppRouting graph
library(cppRouting)
library(sfnetworks)

df_for_cpp <- net_dodgr_sf |> 
  st_drop_geometry() |> 
  select(from = from_id, to = to_id, dist = d_weighted)
head(df_for_cpp)

graph_cpp = makegraph(df_for_cpp, directed = FALSE)
head(graph_cpp[[1]])
str(graph_cpp)
rand_origin = sample(net_dodgr_sf$from_id, 1)
rand_destination = sample(net_dodgr_sf$to_id, 1)
rand_route = get_path_pair(
  Graph = graph_cpp,
  from = rand_origin,
  to = rand_destination
)

rand_route_edges <- tibble(from_id = c(rand_route[[1]],NA),


to_id = c(NA,rand_route[[1]])) |> drop_na() 

rand_route_sf <- bind_rows(
  net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id", "to_id")),
net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id"="to_id", "to_id"="from_id"))) # this is done as the network is undirected

tm_shape(net_dodgr_sf)+
  tm_lines("grey",lwd = 0.8)+
  tm_shape(rand_route_sf)+
  tm_lines("steelblue", lwd = 2)

# Using od data mapped to network nodes from earlier, check the ids are in the graph
all(od_calculated_nodes$from_id %in% net_dodgr_sf$from_id)
od_calculated_nodes = od_calculated |>
  left_join(vert_dodgr_centroids |> select(label, n), join_by(O == label)) |>
  rename(from_id = n) |>
  left_join(vert_dodgr_centroids |> select(label, n), join_by(D == label)) |>
  rename(to_id = n) |>
  # to character: 
  mutate(
    from_id = as.character(from_id),
    to_id = as.character(to_id)
  )


# Perform All-or-Nothing assignment
aon_flows = cppRouting::get_aon(
  Graph = graph_cpp,
  from = od_calculated_nodes$from_id,
  to = od_calculated_nodes$to_id,
  demand = od_calculated_nodes$interaction
)

# Join the flows back to the network for visualization
sfn_edges = net_sfn |> 
  activate("edges") |> 
  st_as_sf()
  
aon_flows_join = aon_flows |>
  mutate(from = as.integer(from), to = as.integer(to))

sfn_edges_with_flow = sfn_edges |>
  left_join(aon_flows_join, by = c("from", "to")) |>
  mutate(flow = ifelse(is.na(flow), 0, flow))

# Plot the results
sfn_edges_with_flow |> 
  filter(flow > 0) |>
  ggplot() +
  geom_sf(aes(color = flow, lwd = flow)) +
  scale_color_viridis_c(trans = "log10") +
  scale_linewidth_continuous(range = c(0.1, 3)) +
  labs(title = "Estimated flows from All-or-Nothing assignment")
```

```{r}
#| eval: false
#| label: fig-dodgr-random-route
rand_route = get_path_pair(
  Graph = graph_cpp,
  from = rand_origin,
  to = rand_destination
)

rand_route_edges <- tibble(from_id = c(rand_route[[1]],NA),
to_id = c(NA,rand_route[[1]])) |> drop_na() 

rand_route_sf <- bind_rows(
  net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id", "to_id")),
net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id"="to_id", "to_id"="from_id"))) # this is done as the network is undirected

tm_shape(net_dodgr_sf)+
  tm_lines("grey",lwd = 0.8)+
  tm_shape(od_rand)+
  tm_dots(col = "red", size = 0.2) +
  tm_shape(rand_route_sf) +
  tm_lines("steelblue", lwd = 2)
```

```{r}
#| label: fig-single-route
#| fig-cap: "A single route for the first OD pair"
#| eval: false
library(sfrouting)

# Get the first OD pair
first_od = od_calculated_nodes[1, ]
from_node = first_od$from_node_id
to_node = first_od$to_node_id

nodes_1_2 = net_sfn |> 
  activate("nodes") |> 
  filter(ID %in% c(from_node, to_node)) |> 
  st_as_sf()
# Calculate the route
single_route = sr_route(net_sfn, from = from_node, to = to_node)
# Currently returns no data. TODO: debug
nrow(single_route)

# Plot the route on top of the network
ggplot() +
  geom_sf(data = st_as_sf(net_sfn, "edges"), color = "grey70") +
  # Add nodes:
  geom_sf(data = nodes_1_2, color = "red", size = 1) +
  geom_sf(data = single_route, color = "blue", size = 2) +
  labs(title = "Route for the first OD pair")
```


The following code uses dodgr for getting an undirected routable network from OSM, and then uses cppRouting for finding the shortest path between two  random points (credit: Juan Fonseca)


```{r}
library(tmap)
library(cppRouting)
library(dodgr)

dodgr_sc <- dodgr_streetnet_sc(st_bbox(study_area))

# 1. Create dodgr graph
# Note: weight_streetnet can be time consuming
net_dodgr_full = weight_streetnet(dodgr_sc, wt_profile = "motorcar")
table(net_dodgr_full$component)
net_dodgr_comp = dodgr_components(net_dodgr_full)
table(net_dodgr_comp$component)
# Clean graph to only include largest connected component
net_dodgr = net_dodgr_comp[net_dodgr_comp$component == 1, ]
table(net_dodgr$component)

net_dodgr_sf = dodgr_to_sf(net_dodgr)
plot(net_dodgr_sf$geometry)
vert_dodgr_sf <- dodgr_vertices(net_dodgr) |>
  st_as_sf(coords = c("x", "y"), crs = st_crs(4326))

set.seed(123)
rand_origin = sample(net_dodgr_sf$from_id, 1)
rand_destination = sample(net_dodgr_sf$to_id, 1)

od_rand = vert_dodgr_sf |> 
  filter(id %in% c(rand_origin, rand_destination))


df_for_cpp <- net_dodgr_sf |> 
  st_drop_geometry() |> 
  select(from = from_id,
     to = to_id,
    dist = d_weighted)

graph_cpp = makegraph(
  df_for_cpp,
directed = FALSE # sf output from dodgr is not directed...
)


rand_route = get_path_pair(
  Graph = graph_cpp,
  from = rand_origin,
  to = rand_destination
)

rand_route_edges <- tibble(from_id = c(rand_route[[1]],NA),
to_id = c(NA,rand_route[[1]])) |> drop_na() 

rand_route_sf <- bind_rows(
  net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id", "to_id")),
net_dodgr_sf |> 
  semi_join(rand_route_edges, by = c("from_id"="to_id", "to_id"="from_id"))) # this is done as the network is undirected

tm_shape(net_dodgr_sf)+
  tm_lines("grey",lwd = 0.8)+
  tm_shape(od_rand)+
  tm_dots(col = "red", size = 0.2) +
  tm_shape(rand_route_sf) +
  tm_lines("steelblue", lwd = 2)

```